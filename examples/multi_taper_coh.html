<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python &mdash; nitime 0.6.dev documentation</title>
    
    <link rel="stylesheet" href="../_static/nitime.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.6.dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="nitime 0.6.dev documentation" href="../index.html" />
    <link rel="up" title="Examples" href="index.html" />
    <link rel="next" title="Multi-taper spectral estimation" href="multi_taper_spectral_estimation.html" />
    <link rel="prev" title="Multitaper F-test for harmonic components" href="mtm_harmonic_test.html" />
  <meta name="keywords" content="nipy, neuroimaging, python, neuroscience, time
				 series">

  </head>
  <body role="document">
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
 <a href="../index.html">
  <img src="../_static/nitime-banner-bg.png" alt="NIPY logo"  border="0" />
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="multi_taper_spectral_estimation.html" title="Multi-taper spectral estimation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mtm_harmonic_test.html" title="Multitaper F-test for harmonic components"
             accesskey="P">previous</a> |</li>
  <li><a href="../index.html">Nitime Home</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Nitime Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">Examples</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

  
<h4> Site Navigation </h4>
  <ul>
    <li><a href="../documentation.html">Documentation</a></li>
    <li><a href="../devel/index.html">Development</a></li>
    <li><a href="../news.html">News</a></li>
  </ul>

<h4> NIPY Community </h4>
  <ul class="simple">
    <li><a class="reference external"
	href="http://nipy.sourceforge.net/">Community Home</a></li>
    <li><a class="reference external"
	href="http://nipy.sourceforge.net/software/projects/">NIPY Projects</a></li>
    <li><a class="reference external"
	href="http://mail.scipy.org/mailman/listinfo/nipy-devel">Mailing List</a></li>
    <li><a class="reference external"
	href="http://nipy.sourceforge.net/software/license/index.html">License</a></li>
  </ul>


  <h4>Previous topic</h4>
  <p class="topless"><a href="mtm_harmonic_test.html"
                        title="previous chapter">Multitaper F-test for harmonic components</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="multi_taper_spectral_estimation.html"
                        title="next chapter">Multi-taper spectral estimation</a></p>

<div id="searchbox-ml" style="display: none">
  <h3>Search mailing list archive</h3>
  <script type="text/javascript">
    function mlsearch(curobj)
    {
    curobj.q.value="site:lists.neuroimaging.scipy.org/pipermail/nipy-devel/ "+curobj.userquery.value
    }
  </script>
  <form action="http://www.google.com/search" method="get" onSubmit="mlsearch(this)">
    <input name="userquery" size="13" type="text" /> <input type="submit" value="Go" />
    <input name="q" type="hidden" />
  </form>
</div>
  
<div id="searchbox-site" style="display: none">
  <h3>Search this site</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" size="13" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    </p>
</div>
<script type="text/javascript">$('#searchbox-ml').show(0);</script>
<script type="text/javascript">$('#searchbox-site').show(0);</script>


        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="multi-taper-coherence-estimation">
<span id="multi-taper-coh"></span><span id="example-multi-taper-coh"></span><h1>Multi-taper coherence estimation<a class="headerlink" href="#multi-taper-coherence-estimation" title="Permalink to this headline">Â¶</a></h1>
<p>Coherence estimation can be done using windowed-spectra. This is the method
used in the example <a class="reference internal" href="resting_state_fmri.html#resting-state"><span>Coherency analysis of fMRI data</span></a>. In addition, multi-taper spectral
estimation can be used in order to calculate coherence and also confidence
intervals for the coherence values that result (see <a class="reference internal" href="multi_taper_spectral_estimation.html#multi-taper-psd"><span>Multi-taper spectral estimation</span></a>)</p>
<p>The data analyzed here is an fMRI data-set contributed by Beth Mormino. The
data is taken from a single subject in a&#8221;resting-state&#8221; scan, in which subjects
are fixating on a cross and maintaining alert wakefulness, but not performing
any other behavioral task.</p>
<p>We start by importing modules/functions we will use in this example and define
variables which will be used as the sampling interval of the TimeSeries
objects and as upper and lower bounds on the frequency range analyzed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.mlab</span> <span class="kn">import</span> <span class="n">csv2rec</span>
<span class="kn">import</span> <span class="nn">scipy.stats.distributions</span> <span class="kn">as</span> <span class="nn">dist</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">fftpack</span>

<span class="kn">import</span> <span class="nn">nitime</span>
<span class="kn">from</span> <span class="nn">nitime.timeseries</span> <span class="kn">import</span> <span class="n">TimeSeries</span>
<span class="kn">from</span> <span class="nn">nitime</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">import</span> <span class="nn">nitime.algorithms</span> <span class="kn">as</span> <span class="nn">alg</span>
<span class="kn">import</span> <span class="nn">nitime.viz</span>
<span class="kn">from</span> <span class="nn">nitime.viz</span> <span class="kn">import</span> <span class="n">drawmatrix_channels</span>
<span class="kn">from</span> <span class="nn">nitime.analysis</span> <span class="kn">import</span> <span class="n">CoherenceAnalyzer</span><span class="p">,</span> <span class="n">MTCoherenceAnalyzer</span>

<span class="n">TR</span> <span class="o">=</span> <span class="mf">1.89</span>
<span class="n">f_ub</span> <span class="o">=</span> <span class="mf">0.15</span>
<span class="n">f_lb</span> <span class="o">=</span> <span class="mf">0.02</span>
</pre></div>
</div>
<p>We read in the data into a recarray from a csv file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">data_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">nitime</span><span class="o">.</span><span class="n">__path__</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;data&#39;</span><span class="p">)</span>

<span class="n">data_rec</span> <span class="o">=</span> <span class="n">csv2rec</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_path</span><span class="p">,</span> <span class="s">&#39;fmri_timeseries.csv&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>The first line in the file contains the names of the different brain regions
(or ROI = regions of interest) from which the time-series were derived. We
extract the data into a regular array, while keeping the names to be used later:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">roi_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_rec</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
<span class="n">nseq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi_names</span><span class="p">)</span>
<span class="n">n_samples</span> <span class="o">=</span> <span class="n">data_rec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nseq</span><span class="p">,</span> <span class="n">n_samples</span><span class="p">))</span>

<span class="k">for</span> <span class="n">n_idx</span><span class="p">,</span> <span class="n">roi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">roi_names</span><span class="p">):</span>
    <span class="n">data</span><span class="p">[</span><span class="n">n_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_rec</span><span class="p">[</span><span class="n">roi</span><span class="p">]</span>
</pre></div>
</div>
<p>We normalize the data in each of the ROIs to be in units of % change:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pdata</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">percent_change</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>We start by performing the detailed analysis, but note that a significant
short-cut is presented below, so if you just want to know how to do this
(without needing to understand the details), skip on down.</p>
<p>We start by defining how many tapers will be used and calculate the values of
the tapers and the associated eigenvalues of each taper:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">NW</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">K</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">NW</span> <span class="o">-</span> <span class="mi">1</span>

<span class="n">tapers</span><span class="p">,</span> <span class="n">eigs</span> <span class="o">=</span> <span class="n">alg</span><span class="o">.</span><span class="n">dpss_windows</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">NW</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
</pre></div>
</div>
<p>We multiply the data by the tapers and derive the fourier transform and the
magnitude of the squared spectra (the power) for each tapered time-series:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">tdata</span> <span class="o">=</span> <span class="n">tapers</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">pdata</span><span class="p">[:,</span> <span class="bp">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">tspectra</span> <span class="o">=</span> <span class="n">fftpack</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">tdata</span><span class="p">)</span>
<span class="c">## mag_sqr_spectra = np.abs(tspectra)</span>
<span class="c">## np.power(mag_sqr_spectra, 2, mag_sqr_spectra)</span>
</pre></div>
</div>
<p>Coherence for real sequences is symmetric, so we calculate this for only half
the spectrum (the other half is equal):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">L</span> <span class="o">=</span> <span class="n">n_samples</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">sides</span> <span class="o">=</span> <span class="s">&#39;onesided&#39;</span>
</pre></div>
</div>
<p>We estimate adaptive weighting of the tapers, based on the data (see
<a class="reference internal" href="multi_taper_spectral_estimation.html#multi-taper-psd"><span>Multi-taper spectral estimation</span></a> for an explanation and references):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nseq</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">L</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nseq</span><span class="p">):</span>
    <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">adaptive_weights</span><span class="p">(</span><span class="n">tspectra</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
</pre></div>
</div>
<p>We proceed to calculate the coherence. We initialize empty data containers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">csd_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nseq</span><span class="p">,</span> <span class="n">nseq</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="s">&#39;D&#39;</span><span class="p">)</span>
<span class="n">psd_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">nseq</span><span class="p">,</span> <span class="n">nseq</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="n">coh_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nseq</span><span class="p">,</span> <span class="n">nseq</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="s">&#39;d&#39;</span><span class="p">)</span>
<span class="n">coh_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">coh_mat</span><span class="p">)</span>
</pre></div>
</div>
<p>Looping over the ROIs:</p>
<div class="highlight-python"><div class="highlight"><pre>for i in xrange(nseq):
    for j in xrange(i):
</pre></div>
</div>
<p>We calculate the multi-tapered cross spectrum between each two
time-series:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sxy</span> <span class="o">=</span> <span class="n">alg</span><span class="o">.</span><span class="n">mtm_cross_spectrum</span><span class="p">(</span>
   <span class="n">tspectra</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tspectra</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">sides</span><span class="o">=</span><span class="s">&#39;onesided&#39;</span>
 <span class="p">)</span>
</pre></div>
</div>
<p>And the individual PSD for each:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">sxx</span> <span class="o">=</span> <span class="n">alg</span><span class="o">.</span><span class="n">mtm_cross_spectrum</span><span class="p">(</span>
   <span class="n">tspectra</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tspectra</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sides</span><span class="o">=</span><span class="s">&#39;onesided&#39;</span>
   <span class="p">)</span>
<span class="n">syy</span> <span class="o">=</span> <span class="n">alg</span><span class="o">.</span><span class="n">mtm_cross_spectrum</span><span class="p">(</span>
   <span class="n">tspectra</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">tspectra</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">sides</span><span class="o">=</span><span class="s">&#39;onesided&#39;</span>
   <span class="p">)</span>

<span class="n">psd_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sxx</span>
<span class="n">psd_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">syy</span>
</pre></div>
</div>
<p>Coherence is : <img class="math" src="../_images/math/53335aa532b1bde19676681da0d88ab9ba54985d.png" alt="Coh_{xy}(\lambda) = \frac{|{f_{xy}(\lambda)}|^2}{f_{xx}(\lambda) \cdot f_{yy}(\lambda)}"/></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coh_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sxy</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
<span class="n">coh_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="p">(</span><span class="n">sxx</span> <span class="o">*</span> <span class="n">syy</span><span class="p">)</span>
<span class="n">csd_mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sxy</span>
</pre></div>
</div>
<p>The variance from the different samples is calculated using a jack-knife
approach:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
    <span class="n">coh_var</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">jackknifed_coh_variance</span><span class="p">(</span>
       <span class="n">tspectra</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tspectra</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">eigs</span><span class="p">,</span> <span class="n">adaptive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
       <span class="p">)</span>
</pre></div>
</div>
<p>This measure is normalized, based on the number of tapers:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coh_mat_xform</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">normalize_coherence</span><span class="p">(</span><span class="n">coh_mat</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>We calculate 95% confidence intervals based on the jack-knife variance
calculation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t025_limit</span> <span class="o">=</span> <span class="n">coh_mat_xform</span> <span class="o">+</span> <span class="n">dist</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="o">.</span><span class="mo">025</span><span class="p">,</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">coh_var</span><span class="p">)</span>
<span class="n">t975_limit</span> <span class="o">=</span> <span class="n">coh_mat_xform</span> <span class="o">+</span> <span class="n">dist</span><span class="o">.</span><span class="n">t</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="o">.</span><span class="mi">975</span><span class="p">,</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">coh_var</span><span class="p">)</span>


<span class="n">utils</span><span class="o">.</span><span class="n">normal_coherence_to_unit</span><span class="p">(</span><span class="n">t025_limit</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">t025_limit</span><span class="p">)</span>
<span class="n">utils</span><span class="o">.</span><span class="n">normal_coherence_to_unit</span><span class="p">(</span><span class="n">t975_limit</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">K</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">t975_limit</span><span class="p">)</span>

<span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="n">n_samples</span><span class="p">:</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">TR</span><span class="p">),</span> <span class="n">L</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">TR</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>We look only at frequencies between 0.02 and 0.15 (the physiologically
relevant band, see <a class="reference external" href="http://imaging.mrc-cbu.cam.ac.uk/imaging/DesignEfficiency">http://imaging.mrc-cbu.cam.ac.uk/imaging/DesignEfficiency</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">freq_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">freqs</span> <span class="o">&gt;</span> <span class="n">f_lb</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">freqs</span> <span class="o">&lt;</span> <span class="n">f_ub</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>We extract the coherence and average over all these frequency bands:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">coh_mat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">freq_idx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># Averaging on the last dimension</span>
</pre></div>
</div>
<p>The next line calls the visualization routine which displays the data</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fig01</span> <span class="o">=</span> <span class="n">drawmatrix_channels</span><span class="p">(</span><span class="n">coh</span><span class="p">,</span>
                            <span class="n">roi_names</span><span class="p">,</span>
                            <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span>
                            <span class="n">color_anchor</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">title</span><span class="o">=</span><span class="s">&#39;MTM Coherence&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/multi_taper_coh_01.png"><img alt="../_images/multi_taper_coh_01.png" src="../_images/multi_taper_coh_01.png" style="width: 500px;" /></a>
<p>Next we perform the same analysis, using the nitime object oriented interface.</p>
<p>We start by initializing a TimeSeries object with this data and with the
sampling_interval provided above. We set the metadata &#8216;roi&#8217; field with the ROI
names.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">T</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">pdata</span><span class="p">,</span> <span class="n">sampling_interval</span><span class="o">=</span><span class="n">TR</span><span class="p">)</span>
<span class="n">T</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">&#39;roi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">roi_names</span>
</pre></div>
</div>
<p>We initialize an MTCoherenceAnalyzer object with the TimeSeries object</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">C2</span> <span class="o">=</span> <span class="n">MTCoherenceAnalyzer</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<p>The relevant indices in the Analyzer object are derived:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">freq_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">C2</span><span class="o">.</span><span class="n">frequencies</span> <span class="o">&gt;</span> <span class="mf">0.02</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">C2</span><span class="o">.</span><span class="n">frequencies</span> <span class="o">&lt;</span> <span class="mf">0.15</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The call to C2.coherence triggers the computation and this is averaged over the
frequency range of interest in the same line and then displayed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">C2</span><span class="o">.</span><span class="n">coherence</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">freq_idx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># Averaging on the last dimension</span>
<span class="n">fig02</span> <span class="o">=</span> <span class="n">drawmatrix_channels</span><span class="p">(</span><span class="n">coh</span><span class="p">,</span>
                            <span class="n">roi_names</span><span class="p">,</span>
                            <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span>
                            <span class="n">color_anchor</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">title</span><span class="o">=</span><span class="s">&#39;MTCoherenceAnalyzer&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/multi_taper_coh_02.png"><img alt="../_images/multi_taper_coh_02.png" src="../_images/multi_taper_coh_02.png" style="width: 500px;" /></a>
<p>For comparison, we also perform the analysis using the standard
CoherenceAnalyzer object, which does the analysis using Welch&#8217;s windowed
periodogram, instead of the multi-taper spectral estimation method (see
<span class="xref std std-ref">resting_state</span> for a more thorough analysis of this data using this
method):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">C3</span> <span class="o">=</span> <span class="n">CoherenceAnalyzer</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

<span class="n">freq_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">C3</span><span class="o">.</span><span class="n">frequencies</span> <span class="o">&gt;</span> <span class="n">f_lb</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">C3</span><span class="o">.</span><span class="n">frequencies</span> <span class="o">&lt;</span> <span class="n">f_ub</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

<span class="c">#Extract the coherence and average across these frequency bands:</span>
<span class="n">coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">C3</span><span class="o">.</span><span class="n">coherence</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">freq_idx</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># Averaging on the last dimension</span>
<span class="n">fig03</span> <span class="o">=</span> <span class="n">drawmatrix_channels</span><span class="p">(</span><span class="n">coh</span><span class="p">,</span>
                            <span class="n">roi_names</span><span class="p">,</span>
                            <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mf">10.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span>
                            <span class="n">color_anchor</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">title</span><span class="o">=</span><span class="s">&#39;CoherenceAnalyzer&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference external image-reference" href="../_images/multi_taper_coh_03.png"><img alt="../_images/multi_taper_coh_03.png" src="../_images/multi_taper_coh_03.png" style="width: 500px;" /></a>
<p>plt.show() is called in order to display the figures:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition-example-source-code admonition">
<p class="first admonition-title">Example source code</p>
<p class="last">You can download <a class="reference download internal" href="../_downloads/multi_taper_coh.py"><code class="xref download docutils literal"><span class="pre">the</span> <span class="pre">full</span> <span class="pre">source</span> <span class="pre">code</span> <span class="pre">of</span> <span class="pre">this</span> <span class="pre">example</span></code></a>.
This same script is also included in the Nitime source distribution under the
<code class="file docutils literal"><span class="pre">doc/examples/</span></code> directory.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="multi_taper_spectral_estimation.html" title="Multi-taper spectral estimation"
             >next</a> |</li>
        <li class="right" >
          <a href="mtm_harmonic_test.html" title="Multitaper F-test for harmonic components"
             >previous</a> |</li>
  <li><a href="../index.html">Nitime Home</a> |&nbsp;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Nitime Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >Examples</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2009, Neuroimaging in Python team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.4.
    </div>
  </body>
</html>